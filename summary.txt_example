＜Directory Structure＞

=== Tree for . ===
.
├── src
│   └── main.rs
├── .gitignore
├── Cargo.toml
├── README.md
└── summary.txt

＜File Contents＞

--------------------------------------------------------------------------------
.gitignore (in .):
--------------------------------------------------------------------------------
# Created by https://www.toptal.com/developers/gitignore/api/rust
# Edit at https://www.toptal.com/developers/gitignore?templates=rust

### Rust ###
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# End of https://www.toptal.com/developers/gitignore/api/rust



--------------------------------------------------------------------------------
Cargo.toml (in .):
--------------------------------------------------------------------------------
[package]
name = "oreuit"
version = "0.1.0"
edition = "2021"
authors = ["Name"]
rust-version = "1.70"

[dependencies]
clap = { version = "4.1", features = ["derive"] }
walkdir = "2.3"
encoding_rs = "0.8"
arboard = { version = "3.4.1", optional = true }

[features]
default = []
clipboard = ["dep:arboard"]

--------------------------------------------------------------------------------
README.md (in .):
--------------------------------------------------------------------------------
# oreuit

- **oreuit** is a tool that generates a text report summarizing the file structure and contents within specified directories. Inspired by [uithub](https://uithub.com/).
- It allows visualization of directory trees and bulk viewing of file contents for codebases without repositories, such as those not hosted on GitHub.

# Installation

## Requirements

- [Rust](https://www.rust-lang.org/) installed (version 1.70 or higher recommended)

## Installation Steps

1.  **Clone the Repository or Download the Code**
    Obtain the source code of this tool from GitHub or other sources.

    ```bash
    git clone https://github.com/yuki-inaho/uithub_like_text_generator.git # Use HTTPS or SSH URL as appropriate
    cd uithub_like_text_generator
    ```

2.  **Build**
    Execute the following command within the project directory to create a release build.

    ```bash
    # Standard build (without clipboard support)
    cargo build --release

    # Build with clipboard support (if you need the -c option)
    # cargo build --release --features clipboard
    ```
    If you plan to use the `-c, --clipboard` option, uncomment and run the second build command.

3.  **Place the Executable**
    After the build completes, the executable will be generated at `./target/release/oreuit`.
    Add it to your system's PATH or specify the execution path as needed.

# Usage

The basic usage involves specifying the target directory/directories and options when running the tool. Below are the main command-line options and their descriptions.

## Available Options

-   `-d, --directory <DIRECTORIES>`
    Specify the directory or directories (comma-separated) to explore. If not specified, the current directory (`.`) is used. (Example: `-d src,tests`)

-   `-e, --extensions <EXTENSIONS>`
    Provide a comma-separated list of allowed file extensions. (Example: `-e .txt,.md,.py`)
    If left empty, the default list (`.txt`, `.md`, `.py`, `.js`, `.java`, `.cpp`, `.c`, `.cs`, `.rb`, `.go`, `.rs`, `.hpp`) is used.

-   `-i, --ignore-extensions <EXTENSIONS>`
    Provide a comma-separated list of file extensions to ignore. (Example: `-i .lock,.md`)
    The default value is:
    ```
    .bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif
    ```

-   `-o, --output <OUTPUT>`
    Specify the output file name. The default is `summary.txt`.

-   `-c, --clipboard`
    Instead of writing the output to a file, copy the results to the clipboard.

    **Note:** Requires the tool to be built with the `clipboard` feature enabled (see Installation section).

-   `--ignore-dirs <DIRS>`
    Provide a comma-separated list of directory names to ignore.
    (Example: `.git,node_modules,__pycache__,target`)
    The default value is:
    ```
    .git,.vscode,target,node_modules,__pycache__,.idea,build,dist
    ```

-   `--max-size <MAX_SIZE>`
    Specify the maximum file size (in bytes) for reading file contents. The default is `10485760` (10MB).
    Files exceeding the specified size will have their content extraction skipped.

-   `-w, --whitelist-filenames <FILENAMES>`
    Specify a comma-separated list of filenames that are always included, regardless of their file extension or location. (Example: `Dockerfile,Makefile`)

---

## Command and Output Examples

Example command:

```bash
./target/release/oreuit -d src -o summary_src.txt --ignore-dirs ".git,target"
```

This command scans the src directory, ignores .git and target subdirectories, and writes the output to summary_src.txt.


--------------------------------------------------------------------------------
src/main.rs (in .):
--------------------------------------------------------------------------------
use clap::Parser;
use encoding_rs::SHIFT_JIS;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Tool to summarize directory structure and file contents
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "A tool to summarize directory structure and file contents (similar to uithub)"
)]
struct Args {
    /// Directories to explore (comma-separated, default is the current directory)
    #[clap(short = 'd', long = "directory", default_value = ".")]
    directories: String,

    /// Allowed file extensions (comma-separated, e.g., .txt,.md,.py). 
    /// Prefix with '+,' to ADD to the default list (e.g., +,.json,.vue). 
    /// If not specified, the default list is used.
    #[clap(short = 'e', long = "extensions")]
    extensions: Option<String>,

    /// File extensions to ignore (comma-separated, e.g., .bin,.zip,...). If empty, no extensions are ignored
    #[clap(
        short = 'i',
        long = "ignore-extensions",
        default_value = ".bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif"
    )]
    ignore_extensions: String,

    /// Output file name (default is summary.txt)
    #[clap(short = 'o', long = "output", default_value = "summary.txt")]
    output: String,

    /// Maximum file size to read (in bytes, default is 10485760 = 10MB)
    #[clap(long = "max-size", default_value = "10485760")]
    max_size: u64,

    /// Copy output to clipboard instead of writing to a file
    #[clap(short = 'c', long = "clipboard")]
    clipboard: bool,

    /// Directory names to ignore (comma-separated, e.g., .git,node_modules,__pycache__, etc.)
    /// Prefix with '+,' to ADD to the default list (e.g., +,my_temp,build2).
    #[clap(long = "ignore-dirs")]
    ignore_dirs: Option<String>,

    /// Filenames to whitelist (comma-separated, e.g., Dockerfile,Makefile). These are always included.
    #[clap(short = 'w', long = "whitelist-filenames", default_value = "Dockerfile,Makefile")]
    whitelist_filenames: String,
}

/// Determines if a file is binary by checking for NUL bytes in the first 1024 bytes
fn is_binary(file_path: &Path) -> bool {
    if let Ok(mut file) = fs::File::open(file_path) {
        let mut buffer = [0u8; 1024];
        if let Ok(n) = file.read(&mut buffer) {
            return buffer[..n].iter().any(|&b| b == 0);
        }
    }
    true
}

/// Attempts to read a file as UTF-8, and if it fails, tries to decode using SHIFT_JIS.
/// If both attempts fail, returns "[Cannot decode file content]".
fn read_file_contents(file_path: &Path) -> String {
    match fs::read_to_string(file_path) {
        Ok(text) => text,
        Err(_) => match fs::read(file_path) {
            Ok(bytes) => {
                let (cow, _, had_errors) = SHIFT_JIS.decode(&bytes);
                if had_errors {
                    "[Cannot decode file content]".to_string()
                } else {
                    cow.into_owned()
                }
            }
            Err(_) => "[Cannot decode file content]".to_string(),
        },
    }
}

/// Recursively searches the specified directory and lists files that
/// - Match allowed extensions
/// - Do not have ignored extensions
/// - Are in the whitelist_filenames (if any)
/// Files within ignored directories are not searched.
fn collect_files(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> Vec<PathBuf> {
    let walker = WalkDir::new(directory).into_iter().filter_entry(|e| {
        if e.file_type().is_dir() {
            if let Some(name) = e.file_name().to_str() {
                return !ignore_dirs.contains(&name.to_string());
            }
        }
        true
    });

    let mut files = Vec::new();
    for entry in walker.filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let path = entry.path();
            let file_name = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
            let is_whitelisted = whitelist_filenames.contains(file_name);

            if !is_whitelisted {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    let ext_formatted = format!(".{}", ext.to_lowercase());
                    if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                        continue;
                    }
                    if ignore.contains(&ext_formatted) {
                        continue;
                    }
                } else {
                    // 拡張子がない場合でも、ファイル名が英数字・記号のみ（例: .gitignore, Makefile, LICENSE等）は許可
                    let fname = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
                    let allowed_no_ext = [
                        "Makefile", "Dockerfile", "LICENSE", "README", ".gitignore", ".gitattributes"
                    ];
                    if !allowed.is_empty() && !allowed_no_ext.contains(&fname) {
                        continue;
                    }
                }
            }
            files.push(path.to_path_buf());
        }
    }

    files.sort_by(|a, b| {
        a.strip_prefix(directory)
            .unwrap_or(a)
            .cmp(b.strip_prefix(directory).unwrap_or(b))
    });
    files
}

/// Generates a tree structure of the specified directory.
fn build_tree(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> String {
    // エラー (E0716) 修正箇所 1: String を取得してライフタイム問題を解決
    let base_name = match directory.file_name().and_then(|s| s.to_str()) {
        Some(s) => s.to_string(),
        None => directory.to_string_lossy().into_owned(), // .into_owned() で String に変換
    };
    let mut lines = vec![base_name]; // String を vec に移動
    build_tree_helper(
        directory,
        "",
        allowed,
        ignore,
        ignore_dirs,
        whitelist_filenames,
        &mut lines,
    );
    lines.join("\n")
}

/// Helper function that recursively traverses the directory structure and builds the tree string
fn build_tree_helper(
    path: &Path,
    prefix: &str,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
    lines: &mut Vec<String>, // String を受け取るように変更
) {
    let mut entries: Vec<fs::DirEntry> = match fs::read_dir(path) {
        Ok(iter) => iter.filter_map(|e| e.ok()).collect(),
        Err(_) => return,
    };
    entries.sort_by_key(|e| e.file_name());

    let mut dirs = Vec::new();
    let mut files = Vec::new();
    for entry in entries {
        let entry_path = entry.path();
        let name = entry.file_name().into_string().unwrap_or_default();

        if entry_path.is_dir() {
            if ignore_dirs.contains(&name) {
                continue;
            }
            dirs.push(entry);
        } else if entry_path.is_file() {
            let is_whitelisted = whitelist_filenames.contains(&name);
            if !is_whitelisted {
                if let Some(ext_os) = entry_path.extension() {
                    if let Some(ext) = ext_os.to_str() {
                        let ext_formatted = format!(".{}", ext.to_lowercase());
                        if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                            continue;
                        }
                        if ignore.contains(&ext_formatted) {
                            continue;
                        }
                    }
                } else {
                    // 拡張子がない場合でも、ファイル名が英数字・記号のみ（例: .gitignore, Makefile, LICENSE等）は許可
                    let fname = entry_path.file_name().and_then(|f| f.to_str()).unwrap_or("");
                    let allowed_no_ext = [
                        "Makefile", "Dockerfile", "LICENSE", "README", ".gitignore", ".gitattributes"
                    ];
                    if !allowed.is_empty() && !allowed_no_ext.contains(&fname) {
                        continue;
                    }
                }
            }
            files.push(entry);
        }
    }

    let mut all_entries = Vec::new();
    for d in dirs {
        all_entries.push((d, true));
    }
    for f in files {
        all_entries.push((f, false));
    }

    let count = all_entries.len();
    for (i, (entry, is_dir)) in all_entries.into_iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let name = entry.file_name().into_string().unwrap_or_default();
        lines.push(format!("{}{}{}", prefix, connector, name));

        if is_dir {
            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };
            build_tree_helper(
                &entry.path(),
                &new_prefix,
                allowed,
                ignore,
                ignore_dirs,
                whitelist_filenames,
                lines,
            );
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    let directories: Vec<PathBuf> = args.directories
        .split(',')
        .filter_map(|s| {
            let s = s.trim();
            if s.is_empty() {
                None
            } else {
                let path = PathBuf::from(s);
                 if !path.exists() {
                    eprintln!("Warning: Directory not found, skipping: {}", path.display());
                    None
                } else if !path.is_dir() {
                     eprintln!("Warning: Path is not a directory, skipping: {}", path.display());
                     None
                }
                else {
                    Some(path)
                }
            }
        })
        .collect();

    if directories.is_empty() {
        eprintln!("Error: No valid directories specified or found.");
        return Ok(());
    }


    let default_allowed: HashSet<String> = [
        ".txt", ".md", ".py", ".js", ".java", ".cpp", ".c", ".cs", ".rb", ".go", ".rs", ".hpp", ".ts", ".tsx", ".d.ts", ".jsx", ".toml"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let allowed: HashSet<String> = match &args.extensions {
        None => default_allowed.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_allowed.clone()
            } else if val.starts_with("+,") {
                let mut set = default_allowed.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_lowercase();
                    if s.is_empty() {
                        continue;
                    }
                    if s.starts_with('.') {
                        set.insert(s);
                    } else {
                        set.insert(format!(".{}", s));
                    }
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_lowercase();
                        if s.is_empty() {
                            None
                        } else if s.starts_with('.') {
                            Some(s)
                        } else {
                            Some(format!(".{}", s))
                        }
                    })
                    .collect()
            }
        }
    };

    let ignore: HashSet<String> = args
        .ignore_extensions
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_lowercase();
            if s.is_empty() {
                None
            } else if s.starts_with('.') {
                Some(s)
            } else {
                Some(format!(".{}", s))
            }
        })
        .collect();

    let default_ignore_dirs: HashSet<String> = [
        ".git", ".vscode", "target", "node_modules", "__pycache__", ".idea", "build", "dist", ".ruff_cache"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let ignore_dirs: HashSet<String> = match &args.ignore_dirs {
        None => default_ignore_dirs.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_ignore_dirs.clone()
            } else if val.starts_with("+,") {
                let mut set = default_ignore_dirs.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_string();
                    if s.is_empty() {
                        continue;
                    }
                    set.insert(s);
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_string();
                        if s.is_empty() {
                            None
                        } else {
                            Some(s)
                        }
                    })
                    .collect()
            }
        }
    };

    let whitelist_filenames: HashSet<String> = args
        .whitelist_filenames
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_string();
            if s.is_empty() {
                None
            } else {
                Some(s)
            }
        })
        .collect();


    let mut all_tree_text = String::new();
    let mut all_file_contents = String::new();

    for dir in &directories {
        // エラー (E0716) 修正箇所 2: String を取得してライフタイム問題を解決
        let dir_name_for_header = match dir.file_name().and_then(|s| s.to_str()) {
            Some(s) => s.to_string(),
            None => dir.to_string_lossy().into_owned(), // .into_owned() で String に変換
        };

        let tree_text = build_tree(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );

        // format! に String を渡す（自動的に参照される）
        all_tree_text.push_str(&format!("=== Tree for {} ===\n{}\n\n", dir_name_for_header, tree_text));


        let files = collect_files(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );


        for file in files {
            let relative_path = file
                .strip_prefix(dir)
                .unwrap_or(&file)
                .to_string_lossy(); // format! 内で使われるだけなので Cow のままでも OK

            // format! に String を渡す
            let header = format!(
                "--------------------------------------------------------------------------------\n{} (in {}):\n--------------------------------------------------------------------------------\n",
                relative_path, dir_name_for_header // ここでも dir_name_for_header (String) を使用
            );
            let size = fs::metadata(&file).map(|m| m.len()).unwrap_or(0);
            let content = if size > args.max_size {
                "[File size exceeds limit; skipped]\n".to_string()
            } else if is_binary(&file) {
                "[Binary file skipped]\n".to_string()
            } else {
                read_file_contents(&file)
            };
            all_file_contents.push_str(&header);
            all_file_contents.push_str(&content);
            all_file_contents.push_str("\n\n");
        }
    }

    if !all_tree_text.is_empty() {
         all_tree_text.pop();
        all_tree_text.pop();
    }
     if !all_file_contents.is_empty() {
         all_file_contents.pop();
        all_file_contents.pop();
    }


    let output_text = format!(
        "＜Directory Structure＞\n\n{}\n\n＜File Contents＞\n\n{}",
        all_tree_text, all_file_contents
    );


    if args.clipboard {
         #[cfg(feature = "clipboard")]
        {
            // arboard は Cargo.toml で optional = true と features で設定されている前提
            match arboard::Clipboard::new() {
                Ok(mut clipboard) => {
                    clipboard.set_text(output_text)?;
                    println!("Output content has been copied to the clipboard.");
                }
                Err(e) => {
                    eprintln!("Failed to access the clipboard: {}. Try writing to a file instead.", e);
                 }
            }
        }
        #[cfg(not(feature = "clipboard"))]
        {
              eprintln!("Clipboard feature is not enabled. Please compile with '--features clipboard' or use the -o option to write to a file.");
         }

    } else {
        fs::write(&args.output, output_text)?;
        println!("Output completed: {}", args.output);
    }
    Ok(())
}


--------------------------------------------------------------------------------
summary.txt (in .):
--------------------------------------------------------------------------------
＜Directory Structure＞

=== Tree for . ===
.
├── src
│   └── main.rs
├── README.md
└── summary.txt

＜File Contents＞

--------------------------------------------------------------------------------
README.md (in .):
--------------------------------------------------------------------------------
# oreuit

- **oreuit** is a tool that generates a text report summarizing the file structure and contents within specified directories. Inspired by [uithub](https://uithub.com/).
- It allows visualization of directory trees and bulk viewing of file contents for codebases without repositories, such as those not hosted on GitHub.

# Installation

## Requirements

- [Rust](https://www.rust-lang.org/) installed (version 1.70 or higher recommended)

## Installation Steps

1.  **Clone the Repository or Download the Code**
    Obtain the source code of this tool from GitHub or other sources.

    ```bash
    git clone https://github.com/yuki-inaho/uithub_like_text_generator.git # Use HTTPS or SSH URL as appropriate
    cd uithub_like_text_generator
    ```

2.  **Build**
    Execute the following command within the project directory to create a release build.

    ```bash
    # Standard build (without clipboard support)
    cargo build --release

    # Build with clipboard support (if you need the -c option)
    # cargo build --release --features clipboard
    ```
    If you plan to use the `-c, --clipboard` option, uncomment and run the second build command.

3.  **Place the Executable**
    After the build completes, the executable will be generated at `./target/release/oreuit`.
    Add it to your system's PATH or specify the execution path as needed.

# Usage

The basic usage involves specifying the target directory/directories and options when running the tool. Below are the main command-line options and their descriptions.

## Available Options

-   `-d, --directory <DIRECTORIES>`
    Specify the directory or directories (comma-separated) to explore. If not specified, the current directory (`.`) is used. (Example: `-d src,tests`)

-   `-e, --extensions <EXTENSIONS>`
    Provide a comma-separated list of allowed file extensions. (Example: `-e .txt,.md,.py`)
    If left empty, the default list (`.txt`, `.md`, `.py`, `.js`, `.java`, `.cpp`, `.c`, `.cs`, `.rb`, `.go`, `.rs`, `.hpp`) is used.

-   `-i, --ignore-extensions <EXTENSIONS>`
    Provide a comma-separated list of file extensions to ignore. (Example: `-i .lock,.md`)
    The default value is:
    ```
    .bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif
    ```

-   `-o, --output <OUTPUT>`
    Specify the output file name. The default is `summary.txt`.

-   `-c, --clipboard`
    Instead of writing the output to a file, copy the results to the clipboard.

    **Note:** Requires the tool to be built with the `clipboard` feature enabled (see Installation section).

-   `--ignore-dirs <DIRS>`
    Provide a comma-separated list of directory names to ignore.
    (Example: `.git,node_modules,__pycache__,target`)
    The default value is:
    ```
    .git,.vscode,target,node_modules,__pycache__,.idea,build,dist
    ```

-   `--max-size <MAX_SIZE>`
    Specify the maximum file size (in bytes) for reading file contents. The default is `10485760` (10MB).
    Files exceeding the specified size will have their content extraction skipped.

-   `-w, --whitelist-filenames <FILENAMES>`
    Specify a comma-separated list of filenames that are always included, regardless of their file extension or location. (Example: `Dockerfile,Makefile`)

---

## Command and Output Examples

Example command:

```bash
./target/release/oreuit -d src -o summary_src.txt --ignore-dirs ".git,target"
```

This command scans the src directory, ignores .git and target subdirectories, and writes the output to summary_src.txt.


--------------------------------------------------------------------------------
src/main.rs (in .):
--------------------------------------------------------------------------------
use clap::Parser;
use encoding_rs::SHIFT_JIS;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Tool to summarize directory structure and file contents
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "A tool to summarize directory structure and file contents (similar to uithub)"
)]
struct Args {
    /// Directories to explore (comma-separated, default is the current directory)
    #[clap(short = 'd', long = "directory", default_value = ".")]
    directories: String,

    /// Allowed file extensions (comma-separated, e.g., .txt,.md,.py). 
    /// Prefix with '+,' to ADD to the default list (e.g., +,.json,.vue). 
    /// If not specified, the default list is used.
    #[clap(short = 'e', long = "extensions")]
    extensions: Option<String>,

    /// File extensions to ignore (comma-separated, e.g., .bin,.zip,...). If empty, no extensions are ignored
    #[clap(
        short = 'i',
        long = "ignore-extensions",
        default_value = ".bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif"
    )]
    ignore_extensions: String,

    /// Output file name (default is summary.txt)
    #[clap(short = 'o', long = "output", default_value = "summary.txt")]
    output: String,

    /// Maximum file size to read (in bytes, default is 10485760 = 10MB)
    #[clap(long = "max-size", default_value = "10485760")]
    max_size: u64,

    /// Copy output to clipboard instead of writing to a file
    #[clap(short = 'c', long = "clipboard")]
    clipboard: bool,

    /// Directory names to ignore (comma-separated, e.g., .git,node_modules,__pycache__, etc.)
    /// Prefix with '+,' to ADD to the default list (e.g., +,my_temp,build2).
    #[clap(long = "ignore-dirs")]
    ignore_dirs: Option<String>,

    /// Filenames to whitelist (comma-separated, e.g., Dockerfile,Makefile). These are always included.
    #[clap(short = 'w', long = "whitelist-filenames", default_value = "Dockerfile,Makefile")]
    whitelist_filenames: String,
}

/// Determines if a file is binary by checking for NUL bytes in the first 1024 bytes
fn is_binary(file_path: &Path) -> bool {
    if let Ok(mut file) = fs::File::open(file_path) {
        let mut buffer = [0u8; 1024];
        if let Ok(n) = file.read(&mut buffer) {
            return buffer[..n].iter().any(|&b| b == 0);
        }
    }
    true
}

/// Attempts to read a file as UTF-8, and if it fails, tries to decode using SHIFT_JIS.
/// If both attempts fail, returns "[Cannot decode file content]".
fn read_file_contents(file_path: &Path) -> String {
    match fs::read_to_string(file_path) {
        Ok(text) => text,
        Err(_) => match fs::read(file_path) {
            Ok(bytes) => {
                let (cow, _, had_errors) = SHIFT_JIS.decode(&bytes);
                if had_errors {
                    "[Cannot decode file content]".to_string()
                } else {
                    cow.into_owned()
                }
            }
            Err(_) => "[Cannot decode file content]".to_string(),
        },
    }
}

/// Recursively searches the specified directory and lists files that
/// - Match allowed extensions
/// - Do not have ignored extensions
/// - Are in the whitelist_filenames (if any)
/// Files within ignored directories are not searched.
fn collect_files(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> Vec<PathBuf> {
    let walker = WalkDir::new(directory).into_iter().filter_entry(|e| {
        if e.file_type().is_dir() {
            if let Some(name) = e.file_name().to_str() {
                return !ignore_dirs.contains(&name.to_string());
            }
        }
        true
    });

    let mut files = Vec::new();
    for entry in walker.filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let path = entry.path();
            let file_name = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
            let is_whitelisted = whitelist_filenames.contains(file_name);

            if !is_whitelisted {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    let ext_formatted = format!(".{}", ext.to_lowercase());
                    if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                        continue;
                    }
                    if ignore.contains(&ext_formatted) {
                        continue;
                    }
                } else {
                    // 拡張子がない場合でも、ファイル名が英数字・記号のみ（例: .gitignore, Makefile, LICENSE等）は許可
                    let fname = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
                    let allowed_no_ext = [
                        "Makefile", "Dockerfile", "LICENSE", "README", ".gitignore", ".gitattributes"
                    ];
                    if !allowed.is_empty() && !allowed_no_ext.contains(&fname) {
                        continue;
                    }
                }
            }
            files.push(path.to_path_buf());
        }
    }

    files.sort_by(|a, b| {
        a.strip_prefix(directory)
            .unwrap_or(a)
            .cmp(b.strip_prefix(directory).unwrap_or(b))
    });
    files
}

/// Generates a tree structure of the specified directory.
fn build_tree(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> String {
    // エラー (E0716) 修正箇所 1: String を取得してライフタイム問題を解決
    let base_name = match directory.file_name().and_then(|s| s.to_str()) {
        Some(s) => s.to_string(),
        None => directory.to_string_lossy().into_owned(), // .into_owned() で String に変換
    };
    let mut lines = vec![base_name]; // String を vec に移動
    build_tree_helper(
        directory,
        "",
        allowed,
        ignore,
        ignore_dirs,
        whitelist_filenames,
        &mut lines,
    );
    lines.join("\n")
}

/// Helper function that recursively traverses the directory structure and builds the tree string
fn build_tree_helper(
    path: &Path,
    prefix: &str,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
    lines: &mut Vec<String>, // String を受け取るように変更
) {
    let mut entries: Vec<fs::DirEntry> = match fs::read_dir(path) {
        Ok(iter) => iter.filter_map(|e| e.ok()).collect(),
        Err(_) => return,
    };
    entries.sort_by_key(|e| e.file_name());

    let mut dirs = Vec::new();
    let mut files = Vec::new();
    for entry in entries {
        let entry_path = entry.path();
        let name = entry.file_name().into_string().unwrap_or_default();

        if entry_path.is_dir() {
            if ignore_dirs.contains(&name) {
                continue;
            }
            dirs.push(entry);
        } else if entry_path.is_file() {
            let is_whitelisted = whitelist_filenames.contains(&name);
            if !is_whitelisted {
                if let Some(ext_os) = entry_path.extension() {
                    if let Some(ext) = ext_os.to_str() {
                        let ext_formatted = format!(".{}", ext.to_lowercase());
                        if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                            continue;
                        }
                        if ignore.contains(&ext_formatted) {
                            continue;
                        }
                    }
                } else {
                    // 拡張子がない場合でも、ファイル名が英数字・記号のみ（例: .gitignore, Makefile, LICENSE等）は許可
                    let fname = entry_path.file_name().and_then(|f| f.to_str()).unwrap_or("");
                    let allowed_no_ext = [
                        "Makefile", "Dockerfile", "LICENSE", "README", ".gitignore", ".gitattributes"
                    ];
                    if !allowed.is_empty() && !allowed_no_ext.contains(&fname) {
                        continue;
                    }
                }
            }
            files.push(entry);
        }
    }

    let mut all_entries = Vec::new();
    for d in dirs {
        all_entries.push((d, true));
    }
    for f in files {
        all_entries.push((f, false));
    }

    let count = all_entries.len();
    for (i, (entry, is_dir)) in all_entries.into_iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let name = entry.file_name().into_string().unwrap_or_default();
        lines.push(format!("{}{}{}", prefix, connector, name));

        if is_dir {
            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };
            build_tree_helper(
                &entry.path(),
                &new_prefix,
                allowed,
                ignore,
                ignore_dirs,
                whitelist_filenames,
                lines,
            );
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    let directories: Vec<PathBuf> = args.directories
        .split(',')
        .filter_map(|s| {
            let s = s.trim();
            if s.is_empty() {
                None
            } else {
                let path = PathBuf::from(s);
                 if !path.exists() {
                    eprintln!("Warning: Directory not found, skipping: {}", path.display());
                    None
                } else if !path.is_dir() {
                     eprintln!("Warning: Path is not a directory, skipping: {}", path.display());
                     None
                }
                else {
                    Some(path)
                }
            }
        })
        .collect();

    if directories.is_empty() {
        eprintln!("Error: No valid directories specified or found.");
        return Ok(());
    }


    let default_allowed: HashSet<String> = [
        ".txt", ".md", ".py", ".js", ".java", ".cpp", ".c", ".cs", ".rb", ".go", ".rs", ".hpp", ".ts", ".tsx", ".d.ts", ".jsx", ".toml"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let allowed: HashSet<String> = match &args.extensions {
        None => default_allowed.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_allowed.clone()
            } else if val.starts_with("+,") {
                let mut set = default_allowed.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_lowercase();
                    if s.is_empty() {
                        continue;
                    }
                    if s.starts_with('.') {
                        set.insert(s);
                    } else {
                        set.insert(format!(".{}", s));
                    }
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_lowercase();
                        if s.is_empty() {
                            None
                        } else if s.starts_with('.') {
                            Some(s)
                        } else {
                            Some(format!(".{}", s))
                        }
                    })
                    .collect()
            }
        }
    };

    let ignore: HashSet<String> = args
        .ignore_extensions
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_lowercase();
            if s.is_empty() {
                None
            } else if s.starts_with('.') {
                Some(s)
            } else {
                Some(format!(".{}", s))
            }
        })
        .collect();

    let default_ignore_dirs: HashSet<String> = [
        ".git", ".vscode", "target", "node_modules", "__pycache__", ".idea", "build", "dist", ".ruff_cache"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let ignore_dirs: HashSet<String> = match &args.ignore_dirs {
        None => default_ignore_dirs.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_ignore_dirs.clone()
            } else if val.starts_with("+,") {
                let mut set = default_ignore_dirs.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_string();
                    if s.is_empty() {
                        continue;
                    }
                    set.insert(s);
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_string();
                        if s.is_empty() {
                            None
                        } else {
                            Some(s)
                        }
                    })
                    .collect()
            }
        }
    };

    let whitelist_filenames: HashSet<String> = args
        .whitelist_filenames
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_string();
            if s.is_empty() {
                None
            } else {
                Some(s)
            }
        })
        .collect();


    let mut all_tree_text = String::new();
    let mut all_file_contents = String::new();

    for dir in &directories {
        // エラー (E0716) 修正箇所 2: String を取得してライフタイム問題を解決
        let dir_name_for_header = match dir.file_name().and_then(|s| s.to_str()) {
            Some(s) => s.to_string(),
            None => dir.to_string_lossy().into_owned(), // .into_owned() で String に変換
        };

        let tree_text = build_tree(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );

        // format! に String を渡す（自動的に参照される）
        all_tree_text.push_str(&format!("=== Tree for {} ===\n{}\n\n", dir_name_for_header, tree_text));


        let files = collect_files(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );


        for file in files {
            let relative_path = file
                .strip_prefix(dir)
                .unwrap_or(&file)
                .to_string_lossy(); // format! 内で使われるだけなので Cow のままでも OK

            // format! に String を渡す
            let header = format!(
                "--------------------------------------------------------------------------------\n{} (in {}):\n--------------------------------------------------------------------------------\n",
                relative_path, dir_name_for_header // ここでも dir_name_for_header (String) を使用
            );
            let size = fs::metadata(&file).map(|m| m.len()).unwrap_or(0);
            let content = if size > args.max_size {
                "[File size exceeds limit; skipped]\n".to_string()
            } else if is_binary(&file) {
                "[Binary file skipped]\n".to_string()
            } else {
                read_file_contents(&file)
            };
            all_file_contents.push_str(&header);
            all_file_contents.push_str(&content);
            all_file_contents.push_str("\n\n");
        }
    }

    if !all_tree_text.is_empty() {
         all_tree_text.pop();
        all_tree_text.pop();
    }
     if !all_file_contents.is_empty() {
         all_file_contents.pop();
        all_file_contents.pop();
    }


    let output_text = format!(
        "＜Directory Structure＞\n\n{}\n\n＜File Contents＞\n\n{}",
        all_tree_text, all_file_contents
    );


    if args.clipboard {
         #[cfg(feature = "clipboard")]
        {
            // arboard は Cargo.toml で optional = true と features で設定されている前提
            match arboard::Clipboard::new() {
                Ok(mut clipboard) => {
                    clipboard.set_text(output_text)?;
                    println!("Output content has been copied to the clipboard.");
                }
                Err(e) => {
                    eprintln!("Failed to access the clipboard: {}. Try writing to a file instead.", e);
                 }
            }
        }
        #[cfg(not(feature = "clipboard"))]
        {
              eprintln!("Clipboard feature is not enabled. Please compile with '--features clipboard' or use the -o option to write to a file.");
         }

    } else {
        fs::write(&args.output, output_text)?;
        println!("Output completed: {}", args.output);
    }
    Ok(())
}


--------------------------------------------------------------------------------
summary.txt (in .):
--------------------------------------------------------------------------------
＜Directory Structure＞

=== Tree for . ===
.
├── src
│   └── main.rs
├── README.md
└── summary.txt

＜File Contents＞

--------------------------------------------------------------------------------
README.md (in .):
--------------------------------------------------------------------------------
# oreuit

- **oreuit** is a tool that generates a text report summarizing the file structure and contents within specified directories. Inspired by [uithub](https://uithub.com/).
- It allows visualization of directory trees and bulk viewing of file contents for codebases without repositories, such as those not hosted on GitHub.

# Installation

## Requirements

- [Rust](https://www.rust-lang.org/) installed (version 1.70 or higher recommended)

## Installation Steps

1.  **Clone the Repository or Download the Code**
    Obtain the source code of this tool from GitHub or other sources.

    ```bash
    git clone https://github.com/yuki-inaho/uithub_like_text_generator.git # Use HTTPS or SSH URL as appropriate
    cd uithub_like_text_generator
    ```

2.  **Build**
    Execute the following command within the project directory to create a release build.

    ```bash
    # Standard build (without clipboard support)
    cargo build --release

    # Build with clipboard support (if you need the -c option)
    # cargo build --release --features clipboard
    ```
    If you plan to use the `-c, --clipboard` option, uncomment and run the second build command.

3.  **Place the Executable**
    After the build completes, the executable will be generated at `./target/release/oreuit`.
    Add it to your system's PATH or specify the execution path as needed.

# Usage

The basic usage involves specifying the target directory/directories and options when running the tool. Below are the main command-line options and their descriptions.

## Available Options

-   `-d, --directory <DIRECTORIES>`
    Specify the directory or directories (comma-separated) to explore. If not specified, the current directory (`.`) is used. (Example: `-d src,tests`)

-   `-e, --extensions <EXTENSIONS>`
    Provide a comma-separated list of allowed file extensions. (Example: `-e .txt,.md,.py`)
    If left empty, the default list (`.txt`, `.md`, `.py`, `.js`, `.java`, `.cpp`, `.c`, `.cs`, `.rb`, `.go`, `.rs`, `.hpp`) is used.

-   `-i, --ignore-extensions <EXTENSIONS>`
    Provide a comma-separated list of file extensions to ignore. (Example: `-i .lock,.md`)
    The default value is:
    ```
    .bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif
    ```

-   `-o, --output <OUTPUT>`
    Specify the output file name. The default is `summary.txt`.

-   `-c, --clipboard`
    Instead of writing the output to a file, copy the results to the clipboard.

    **Note:** Requires the tool to be built with the `clipboard` feature enabled (see Installation section).

-   `--ignore-dirs <DIRS>`
    Provide a comma-separated list of directory names to ignore.
    (Example: `.git,node_modules,__pycache__,target`)
    The default value is:
    ```
    .git,.vscode,target,node_modules,__pycache__,.idea,build,dist
    ```

-   `--max-size <MAX_SIZE>`
    Specify the maximum file size (in bytes) for reading file contents. The default is `10485760` (10MB).
    Files exceeding the specified size will have their content extraction skipped.

-   `-w, --whitelist-filenames <FILENAMES>`
    Specify a comma-separated list of filenames that are always included, regardless of their file extension or location. (Example: `Dockerfile,Makefile`)

---

## Command and Output Examples

Example command:

```bash
./target/release/oreuit -d src -o summary_src.txt --ignore-dirs ".git,target"
```

This command scans the src directory, ignores .git and target subdirectories, and writes the output to summary_src.txt.


--------------------------------------------------------------------------------
src/main.rs (in .):
--------------------------------------------------------------------------------
use clap::Parser;
use encoding_rs::SHIFT_JIS;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Tool to summarize directory structure and file contents
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "A tool to summarize directory structure and file contents (similar to uithub)"
)]
struct Args {
    /// Directories to explore (comma-separated, default is the current directory)
    #[clap(short = 'd', long = "directory", default_value = ".")]
    directories: String,

    /// Allowed file extensions (comma-separated, e.g., .txt,.md,.py). 
    /// Prefix with '+,' to ADD to the default list (e.g., +,.json,.vue). 
    /// If not specified, the default list is used.
    #[clap(short = 'e', long = "extensions")]
    extensions: Option<String>,

    /// File extensions to ignore (comma-separated, e.g., .bin,.zip,...). If empty, no extensions are ignored
    #[clap(
        short = 'i',
        long = "ignore-extensions",
        default_value = ".bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif"
    )]
    ignore_extensions: String,

    /// Output file name (default is summary.txt)
    #[clap(short = 'o', long = "output", default_value = "summary.txt")]
    output: String,

    /// Maximum file size to read (in bytes, default is 10485760 = 10MB)
    #[clap(long = "max-size", default_value = "10485760")]
    max_size: u64,

    /// Copy output to clipboard instead of writing to a file
    #[clap(short = 'c', long = "clipboard")]
    clipboard: bool,

    /// Directory names to ignore (comma-separated, e.g., .git,node_modules,__pycache__, etc.)
    /// Prefix with '+,' to ADD to the default list (e.g., +,my_temp,build2).
    #[clap(long = "ignore-dirs")]
    ignore_dirs: Option<String>,

    /// Filenames to whitelist (comma-separated, e.g., Dockerfile,Makefile). These are always included.
    #[clap(short = 'w', long = "whitelist-filenames", default_value = "Dockerfile,Makefile")]
    whitelist_filenames: String,
}

/// Determines if a file is binary by checking for NUL bytes in the first 1024 bytes
fn is_binary(file_path: &Path) -> bool {
    if let Ok(mut file) = fs::File::open(file_path) {
        let mut buffer = [0u8; 1024];
        if let Ok(n) = file.read(&mut buffer) {
            return buffer[..n].iter().any(|&b| b == 0);
        }
    }
    true
}

/// Attempts to read a file as UTF-8, and if it fails, tries to decode using SHIFT_JIS.
/// If both attempts fail, returns "[Cannot decode file content]".
fn read_file_contents(file_path: &Path) -> String {
    match fs::read_to_string(file_path) {
        Ok(text) => text,
        Err(_) => match fs::read(file_path) {
            Ok(bytes) => {
                let (cow, _, had_errors) = SHIFT_JIS.decode(&bytes);
                if had_errors {
                    "[Cannot decode file content]".to_string()
                } else {
                    cow.into_owned()
                }
            }
            Err(_) => "[Cannot decode file content]".to_string(),
        },
    }
}

/// Recursively searches the specified directory and lists files that
/// - Match allowed extensions
/// - Do not have ignored extensions
/// - Are in the whitelist_filenames (if any)
/// Files within ignored directories are not searched.
fn collect_files(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> Vec<PathBuf> {
    let walker = WalkDir::new(directory).into_iter().filter_entry(|e| {
        if e.file_type().is_dir() {
            if let Some(name) = e.file_name().to_str() {
                return !ignore_dirs.contains(&name.to_string());
            }
        }
        true
    });

    let mut files = Vec::new();
    for entry in walker.filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let path = entry.path();
            let file_name = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
            let is_whitelisted = whitelist_filenames.contains(file_name);

            if !is_whitelisted {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    let ext_formatted = format!(".{}", ext.to_lowercase());
                    if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                        continue;
                    }
                    if ignore.contains(&ext_formatted) {
                        continue;
                    }
                } else {
                    // 拡張子がない場合でも、ファイル名が英数字・記号のみ（例: .gitignore, Makefile, LICENSE等）は許可
                    let fname = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
                    let allowed_no_ext = [
                        "Makefile", "Dockerfile", "LICENSE", "README", ".gitignore", ".gitattributes"
                    ];
                    if !allowed.is_empty() && !allowed_no_ext.contains(&fname) {
                        continue;
                    }
                }
            }
            files.push(path.to_path_buf());
        }
    }

    files.sort_by(|a, b| {
        a.strip_prefix(directory)
            .unwrap_or(a)
            .cmp(b.strip_prefix(directory).unwrap_or(b))
    });
    files
}

/// Generates a tree structure of the specified directory.
fn build_tree(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> String {
    // エラー (E0716) 修正箇所 1: String を取得してライフタイム問題を解決
    let base_name = match directory.file_name().and_then(|s| s.to_str()) {
        Some(s) => s.to_string(),
        None => directory.to_string_lossy().into_owned(), // .into_owned() で String に変換
    };
    let mut lines = vec![base_name]; // String を vec に移動
    build_tree_helper(
        directory,
        "",
        allowed,
        ignore,
        ignore_dirs,
        whitelist_filenames,
        &mut lines,
    );
    lines.join("\n")
}

/// Helper function that recursively traverses the directory structure and builds the tree string
fn build_tree_helper(
    path: &Path,
    prefix: &str,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
    lines: &mut Vec<String>, // String を受け取るように変更
) {
    let mut entries: Vec<fs::DirEntry> = match fs::read_dir(path) {
        Ok(iter) => iter.filter_map(|e| e.ok()).collect(),
        Err(_) => return,
    };
    entries.sort_by_key(|e| e.file_name());

    let mut dirs = Vec::new();
    let mut files = Vec::new();
    for entry in entries {
        let entry_path = entry.path();
        let name = entry.file_name().into_string().unwrap_or_default();

        if entry_path.is_dir() {
            if ignore_dirs.contains(&name) {
                continue;
            }
            dirs.push(entry);
        } else if entry_path.is_file() {
            let is_whitelisted = whitelist_filenames.contains(&name);
            if !is_whitelisted {
                 if let Some(ext_os) = entry_path.extension() {
                    if let Some(ext) = ext_os.to_str() {
                        let ext_formatted = format!(".{}", ext.to_lowercase());
                        if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                            continue;
                        }
                        if ignore.contains(&ext_formatted) {
                            continue;
                        }
                    }
                } else {
                     if !allowed.is_empty() {
                        continue;
                    }
                }
            }
            files.push(entry);
        }
    }

    let mut all_entries = Vec::new();
    for d in dirs {
        all_entries.push((d, true));
    }
    for f in files {
        all_entries.push((f, false));
    }

    let count = all_entries.len();
    for (i, (entry, is_dir)) in all_entries.into_iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let name = entry.file_name().into_string().unwrap_or_default();
        lines.push(format!("{}{}{}", prefix, connector, name));

        if is_dir {
            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };
            build_tree_helper(
                &entry.path(),
                &new_prefix,
                allowed,
                ignore,
                ignore_dirs,
                whitelist_filenames,
                lines,
            );
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    let directories: Vec<PathBuf> = args.directories
        .split(',')
        .filter_map(|s| {
            let s = s.trim();
            if s.is_empty() {
                None
            } else {
                let path = PathBuf::from(s);
                 if !path.exists() {
                    eprintln!("Warning: Directory not found, skipping: {}", path.display());
                    None
                } else if !path.is_dir() {
                     eprintln!("Warning: Path is not a directory, skipping: {}", path.display());
                     None
                }
                else {
                    Some(path)
                }
            }
        })
        .collect();

    if directories.is_empty() {
        eprintln!("Error: No valid directories specified or found.");
        return Ok(());
    }


    let default_allowed: HashSet<String> = [
        ".txt", ".md", ".py", ".js", ".java", ".cpp", ".c", ".cs", ".rb", ".go", ".rs", ".hpp", ".ts", ".tsx", ".d.ts", ".jsx", ".toml"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let allowed: HashSet<String> = match &args.extensions {
        None => default_allowed.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_allowed.clone()
            } else if val.starts_with("+,") {
                let mut set = default_allowed.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_lowercase();
                    if s.is_empty() {
                        continue;
                    }
                    if s.starts_with('.') {
                        set.insert(s);
                    } else {
                        set.insert(format!(".{}", s));
                    }
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_lowercase();
                        if s.is_empty() {
                            None
                        } else if s.starts_with('.') {
                            Some(s)
                        } else {
                            Some(format!(".{}", s))
                        }
                    })
                    .collect()
            }
        }
    };

    let ignore: HashSet<String> = args
        .ignore_extensions
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_lowercase();
            if s.is_empty() {
                None
            } else if s.starts_with('.') {
                Some(s)
            } else {
                Some(format!(".{}", s))
            }
        })
        .collect();

    let default_ignore_dirs: HashSet<String> = [
        ".git", ".vscode", "target", "node_modules", "__pycache__", ".idea", "build", "dist", ".ruff_cache"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let ignore_dirs: HashSet<String> = match &args.ignore_dirs {
        None => default_ignore_dirs.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_ignore_dirs.clone()
            } else if val.starts_with("+,") {
                let mut set = default_ignore_dirs.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_string();
                    if s.is_empty() {
                        continue;
                    }
                    set.insert(s);
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_string();
                        if s.is_empty() {
                            None
                        } else {
                            Some(s)
                        }
                    })
                    .collect()
            }
        }
    };

    let whitelist_filenames: HashSet<String> = args
        .whitelist_filenames
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_string();
            if s.is_empty() {
                None
            } else {
                Some(s)
            }
        })
        .collect();


    let mut all_tree_text = String::new();
    let mut all_file_contents = String::new();

    for dir in &directories {
        // エラー (E0716) 修正箇所 2: String を取得してライフタイム問題を解決
        let dir_name_for_header = match dir.file_name().and_then(|s| s.to_str()) {
            Some(s) => s.to_string(),
            None => dir.to_string_lossy().into_owned(), // .into_owned() で String に変換
        };

        let tree_text = build_tree(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );

        // format! に String を渡す（自動的に参照される）
        all_tree_text.push_str(&format!("=== Tree for {} ===\n{}\n\n", dir_name_for_header, tree_text));


        let files = collect_files(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );


        for file in files {
            let relative_path = file
                .strip_prefix(dir)
                .unwrap_or(&file)
                .to_string_lossy(); // format! 内で使われるだけなので Cow のままでも OK

            // format! に String を渡す
            let header = format!(
                "--------------------------------------------------------------------------------\n{} (in {}):\n--------------------------------------------------------------------------------\n",
                relative_path, dir_name_for_header // ここでも dir_name_for_header (String) を使用
            );
            let size = fs::metadata(&file).map(|m| m.len()).unwrap_or(0);
            let content = if size > args.max_size {
                "[File size exceeds limit; skipped]\n".to_string()
            } else if is_binary(&file) {
                "[Binary file skipped]\n".to_string()
            } else {
                read_file_contents(&file)
            };
            all_file_contents.push_str(&header);
            all_file_contents.push_str(&content);
            all_file_contents.push_str("\n\n");
        }
    }

    if !all_tree_text.is_empty() {
         all_tree_text.pop();
        all_tree_text.pop();
    }
     if !all_file_contents.is_empty() {
         all_file_contents.pop();
        all_file_contents.pop();
    }


    let output_text = format!(
        "＜Directory Structure＞\n\n{}\n\n＜File Contents＞\n\n{}",
        all_tree_text, all_file_contents
    );


    if args.clipboard {
         #[cfg(feature = "clipboard")]
        {
            // arboard は Cargo.toml で optional = true と features で設定されている前提
            match arboard::Clipboard::new() {
                Ok(mut clipboard) => {
                    clipboard.set_text(output_text)?;
                    println!("Output content has been copied to the clipboard.");
                }
                Err(e) => {
                    eprintln!("Failed to access the clipboard: {}. Try writing to a file instead.", e);
                 }
            }
        }
        #[cfg(not(feature = "clipboard"))]
        {
              eprintln!("Clipboard feature is not enabled. Please compile with '--features clipboard' or use the -o option to write to a file.");
         }

    } else {
        fs::write(&args.output, output_text)?;
        println!("Output completed: {}", args.output);
    }
    Ok(())
}


--------------------------------------------------------------------------------
summary.txt (in .):
--------------------------------------------------------------------------------
＜Directory Structure＞

=== Tree for . ===
.
├── src
│   └── main.rs
└── README.md

＜File Contents＞

--------------------------------------------------------------------------------
README.md (in .):
--------------------------------------------------------------------------------
# oreuit

- **oreuit** is a tool that generates a text report summarizing the file structure and contents within specified directories. Inspired by [uithub](https://uithub.com/).
- It allows visualization of directory trees and bulk viewing of file contents for codebases without repositories, such as those not hosted on GitHub.

# Installation

## Requirements

- [Rust](https://www.rust-lang.org/) installed (version 1.70 or higher recommended)

## Installation Steps

1.  **Clone the Repository or Download the Code**
    Obtain the source code of this tool from GitHub or other sources.

    ```bash
    git clone https://github.com/yuki-inaho/uithub_like_text_generator.git # Use HTTPS or SSH URL as appropriate
    cd uithub_like_text_generator
    ```

2.  **Build**
    Execute the following command within the project directory to create a release build.

    ```bash
    # Standard build (without clipboard support)
    cargo build --release

    # Build with clipboard support (if you need the -c option)
    # cargo build --release --features clipboard
    ```
    If you plan to use the `-c, --clipboard` option, uncomment and run the second build command.

3.  **Place the Executable**
    After the build completes, the executable will be generated at `./target/release/oreuit`.
    Add it to your system's PATH or specify the execution path as needed.

# Usage

The basic usage involves specifying the target directory/directories and options when running the tool. Below are the main command-line options and their descriptions.

## Available Options

-   `-d, --directory <DIRECTORIES>`
    Specify the directory or directories (comma-separated) to explore. If not specified, the current directory (`.`) is used. (Example: `-d src,tests`)

-   `-e, --extensions <EXTENSIONS>`
    Provide a comma-separated list of allowed file extensions. (Example: `-e .txt,.md,.py`)
    If left empty, the default list (`.txt`, `.md`, `.py`, `.js`, `.java`, `.cpp`, `.c`, `.cs`, `.rb`, `.go`, `.rs`, `.hpp`) is used.

-   `-i, --ignore-extensions <EXTENSIONS>`
    Provide a comma-separated list of file extensions to ignore. (Example: `-i .lock,.md`)
    The default value is:
    ```
    .bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif
    ```

-   `-o, --output <OUTPUT>`
    Specify the output file name. The default is `summary.txt`.

-   `-c, --clipboard`
    Instead of writing the output to a file, copy the results to the clipboard.

    **Note:** Requires the tool to be built with the `clipboard` feature enabled (see Installation section).

-   `--ignore-dirs <DIRS>`
    Provide a comma-separated list of directory names to ignore.
    (Example: `.git,node_modules,__pycache__,target`)
    The default value is:
    ```
    .git,.vscode,target,node_modules,__pycache__,.idea,build,dist
    ```

-   `--max-size <MAX_SIZE>`
    Specify the maximum file size (in bytes) for reading file contents. The default is `10485760` (10MB).
    Files exceeding the specified size will have their content extraction skipped.

-   `-w, --whitelist-filenames <FILENAMES>`
    Specify a comma-separated list of filenames that are always included, regardless of their file extension or location. (Example: `Dockerfile,Makefile`)

---

## Command and Output Examples

Example command:

```bash
./target/release/oreuit -d src -o summary_src.txt --ignore-dirs ".git,target"
```

This command scans the src directory, ignores .git and target subdirectories, and writes the output to summary_src.txt.


--------------------------------------------------------------------------------
src/main.rs (in .):
--------------------------------------------------------------------------------
use clap::Parser;
use encoding_rs::SHIFT_JIS;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Tool to summarize directory structure and file contents
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "A tool to summarize directory structure and file contents (similar to uithub)"
)]
struct Args {
    /// Directories to explore (comma-separated, default is the current directory)
    #[clap(short = 'd', long = "directory", default_value = ".")]
    directories: String,

    /// Allowed file extensions (comma-separated, e.g., .txt,.md,.py). 
    /// Prefix with '+,' to ADD to the default list (e.g., +,.json,.vue). 
    /// If not specified, the default list is used.
    #[clap(short = 'e', long = "extensions")]
    extensions: Option<String>,

    /// File extensions to ignore (comma-separated, e.g., .bin,.zip,...). If empty, no extensions are ignored
    #[clap(
        short = 'i',
        long = "ignore-extensions",
        default_value = ".bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif"
    )]
    ignore_extensions: String,

    /// Output file name (default is summary.txt)
    #[clap(short = 'o', long = "output", default_value = "summary.txt")]
    output: String,

    /// Maximum file size to read (in bytes, default is 10485760 = 10MB)
    #[clap(long = "max-size", default_value = "10485760")]
    max_size: u64,

    /// Copy output to clipboard instead of writing to a file
    #[clap(short = 'c', long = "clipboard")]
    clipboard: bool,

    /// Directory names to ignore (comma-separated, e.g., .git,node_modules,__pycache__, etc.)
    /// Prefix with '+,' to ADD to the default list (e.g., +,my_temp,build2).
    #[clap(long = "ignore-dirs")]
    ignore_dirs: Option<String>,

    /// Filenames to whitelist (comma-separated, e.g., Dockerfile,Makefile). These are always included.
    #[clap(short = 'w', long = "whitelist-filenames", default_value = "Dockerfile,Makefile")]
    whitelist_filenames: String,
}

/// Determines if a file is binary by checking for NUL bytes in the first 1024 bytes
fn is_binary(file_path: &Path) -> bool {
    if let Ok(mut file) = fs::File::open(file_path) {
        let mut buffer = [0u8; 1024];
        if let Ok(n) = file.read(&mut buffer) {
            return buffer[..n].iter().any(|&b| b == 0);
        }
    }
    true
}

/// Attempts to read a file as UTF-8, and if it fails, tries to decode using SHIFT_JIS.
/// If both attempts fail, returns "[Cannot decode file content]".
fn read_file_contents(file_path: &Path) -> String {
    match fs::read_to_string(file_path) {
        Ok(text) => text,
        Err(_) => match fs::read(file_path) {
            Ok(bytes) => {
                let (cow, _, had_errors) = SHIFT_JIS.decode(&bytes);
                if had_errors {
                    "[Cannot decode file content]".to_string()
                } else {
                    cow.into_owned()
                }
            }
            Err(_) => "[Cannot decode file content]".to_string(),
        },
    }
}

/// Recursively searches the specified directory and lists files that
/// - Match allowed extensions
/// - Do not have ignored extensions
/// - Are in the whitelist_filenames (if any)
/// Files within ignored directories are not searched.
fn collect_files(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> Vec<PathBuf> {
    let walker = WalkDir::new(directory).into_iter().filter_entry(|e| {
        if e.file_type().is_dir() {
            if let Some(name) = e.file_name().to_str() {
                return !ignore_dirs.contains(&name.to_string());
            }
        }
        true
    });

    let mut files = Vec::new();
    for entry in walker.filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let path = entry.path();
            let file_name = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
            let is_whitelisted = whitelist_filenames.contains(file_name);

            if !is_whitelisted {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    let ext_formatted = format!(".{}", ext.to_lowercase());
                    if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                        continue;
                    }
                    if ignore.contains(&ext_formatted) {
                        continue;
                    }
                } else {
                     if !allowed.is_empty() {
                        continue;
                    }
                }
            }
            files.push(path.to_path_buf());
        }
    }

    files.sort_by(|a, b| {
        a.strip_prefix(directory)
            .unwrap_or(a)
            .cmp(b.strip_prefix(directory).unwrap_or(b))
    });
    files
}

/// Generates a tree structure of the specified directory.
fn build_tree(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
) -> String {
    // エラー (E0716) 修正箇所 1: String を取得してライフタイム問題を解決
    let base_name = match directory.file_name().and_then(|s| s.to_str()) {
        Some(s) => s.to_string(),
        None => directory.to_string_lossy().into_owned(), // .into_owned() で String に変換
    };
    let mut lines = vec![base_name]; // String を vec に移動
    build_tree_helper(
        directory,
        "",
        allowed,
        ignore,
        ignore_dirs,
        whitelist_filenames,
        &mut lines,
    );
    lines.join("\n")
}

/// Helper function that recursively traverses the directory structure and builds the tree string
fn build_tree_helper(
    path: &Path,
    prefix: &str,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    whitelist_filenames: &HashSet<String>,
    lines: &mut Vec<String>, // String を受け取るように変更
) {
    let mut entries: Vec<fs::DirEntry> = match fs::read_dir(path) {
        Ok(iter) => iter.filter_map(|e| e.ok()).collect(),
        Err(_) => return,
    };
    entries.sort_by_key(|e| e.file_name());

    let mut dirs = Vec::new();
    let mut files = Vec::new();
    for entry in entries {
        let entry_path = entry.path();
        let name = entry.file_name().into_string().unwrap_or_default();

        if entry_path.is_dir() {
            if ignore_dirs.contains(&name) {
                continue;
            }
            dirs.push(entry);
        } else if entry_path.is_file() {
            let is_whitelisted = whitelist_filenames.contains(&name);
            if !is_whitelisted {
                 if let Some(ext_os) = entry_path.extension() {
                    if let Some(ext) = ext_os.to_str() {
                        let ext_formatted = format!(".{}", ext.to_lowercase());
                        if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                            continue;
                        }
                        if ignore.contains(&ext_formatted) {
                            continue;
                        }
                    }
                } else {
                     if !allowed.is_empty() {
                        continue;
                    }
                }
            }
            files.push(entry);
        }
    }

    let mut all_entries = Vec::new();
    for d in dirs {
        all_entries.push((d, true));
    }
    for f in files {
        all_entries.push((f, false));
    }

    let count = all_entries.len();
    for (i, (entry, is_dir)) in all_entries.into_iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let name = entry.file_name().into_string().unwrap_or_default();
        lines.push(format!("{}{}{}", prefix, connector, name));

        if is_dir {
            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };
            build_tree_helper(
                &entry.path(),
                &new_prefix,
                allowed,
                ignore,
                ignore_dirs,
                whitelist_filenames,
                lines,
            );
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    let directories: Vec<PathBuf> = args.directories
        .split(',')
        .filter_map(|s| {
            let s = s.trim();
            if s.is_empty() {
                None
            } else {
                let path = PathBuf::from(s);
                 if !path.exists() {
                    eprintln!("Warning: Directory not found, skipping: {}", path.display());
                    None
                } else if !path.is_dir() {
                     eprintln!("Warning: Path is not a directory, skipping: {}", path.display());
                     None
                }
                else {
                    Some(path)
                }
            }
        })
        .collect();

    if directories.is_empty() {
        eprintln!("Error: No valid directories specified or found.");
        return Ok(());
    }


    let default_allowed: HashSet<String> = [
        ".txt", ".md", ".py", ".js", ".java", ".cpp", ".c", ".cs", ".rb", ".go", ".rs", ".hpp", ".ts", ".tsx", ".d.ts", ".jsx"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let allowed: HashSet<String> = match &args.extensions {
        None => default_allowed.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_allowed.clone()
            } else if val.starts_with("+,") {
                let mut set = default_allowed.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_lowercase();
                    if s.is_empty() {
                        continue;
                    }
                    if s.starts_with('.') {
                        set.insert(s);
                    } else {
                        set.insert(format!(".{}", s));
                    }
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_lowercase();
                        if s.is_empty() {
                            None
                        } else if s.starts_with('.') {
                            Some(s)
                        } else {
                            Some(format!(".{}", s))
                        }
                    })
                    .collect()
            }
        }
    };

    let ignore: HashSet<String> = args
        .ignore_extensions
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_lowercase();
            if s.is_empty() {
                None
            } else if s.starts_with('.') {
                Some(s)
            } else {
                Some(format!(".{}", s))
            }
        })
        .collect();

    let default_ignore_dirs: HashSet<String> = [
        ".git", ".vscode", "target", "node_modules", "__pycache__", ".idea", "build", "dist", ".ruff_cache"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    let ignore_dirs: HashSet<String> = match &args.ignore_dirs {
        None => default_ignore_dirs.clone(),
        Some(val) => {
            let val = val.trim();
            if val.is_empty() {
                default_ignore_dirs.clone()
            } else if val.starts_with("+,") {
                let mut set = default_ignore_dirs.clone();
                for s in val.trim_start_matches("+,").split(',') {
                    let s = s.trim().to_string();
                    if s.is_empty() {
                        continue;
                    }
                    set.insert(s);
                }
                set
            } else {
                val.split(',')
                    .filter_map(|s| {
                        let s = s.trim().to_string();
                        if s.is_empty() {
                            None
                        } else {
                            Some(s)
                        }
                    })
                    .collect()
            }
        }
    };

    let whitelist_filenames: HashSet<String> = args
        .whitelist_filenames
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_string();
            if s.is_empty() {
                None
            } else {
                Some(s)
            }
        })
        .collect();


    let mut all_tree_text = String::new();
    let mut all_file_contents = String::new();

    for dir in &directories {
        // エラー (E0716) 修正箇所 2: String を取得してライフタイム問題を解決
        let dir_name_for_header = match dir.file_name().and_then(|s| s.to_str()) {
            Some(s) => s.to_string(),
            None => dir.to_string_lossy().into_owned(), // .into_owned() で String に変換
        };

        let tree_text = build_tree(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );

        // format! に String を渡す（自動的に参照される）
        all_tree_text.push_str(&format!("=== Tree for {} ===\n{}\n\n", dir_name_for_header, tree_text));


        let files = collect_files(
            dir,
            &allowed,
            &ignore,
            &ignore_dirs,
            &whitelist_filenames,
        );


        for file in files {
            let relative_path = file
                .strip_prefix(dir)
                .unwrap_or(&file)
                .to_string_lossy(); // format! 内で使われるだけなので Cow のままでも OK

            // format! に String を渡す
            let header = format!(
                "--------------------------------------------------------------------------------\n{} (in {}):\n--------------------------------------------------------------------------------\n",
                relative_path, dir_name_for_header // ここでも dir_name_for_header (String) を使用
            );
            let size = fs::metadata(&file).map(|m| m.len()).unwrap_or(0);
            let content = if size > args.max_size {
                "[File size exceeds limit; skipped]\n".to_string()
            } else if is_binary(&file) {
                "[Binary file skipped]\n".to_string()
            } else {
                read_file_contents(&file)
            };
            all_file_contents.push_str(&header);
            all_file_contents.push_str(&content);
            all_file_contents.push_str("\n\n");
        }
    }

    if !all_tree_text.is_empty() {
         all_tree_text.pop();
        all_tree_text.pop();
    }
     if !all_file_contents.is_empty() {
         all_file_contents.pop();
        all_file_contents.pop();
    }


    let output_text = format!(
        "＜Directory Structure＞\n\n{}\n\n＜File Contents＞\n\n{}",
        all_tree_text, all_file_contents
    );


    if args.clipboard {
         #[cfg(feature = "clipboard")]
        {
            // arboard は Cargo.toml で optional = true と features で設定されている前提
            match arboard::Clipboard::new() {
                Ok(mut clipboard) => {
                    clipboard.set_text(output_text)?;
                    println!("Output content has been copied to the clipboard.");
                }
                Err(e) => {
                    eprintln!("Failed to access the clipboard: {}. Try writing to a file instead.", e);
                 }
            }
        }
        #[cfg(not(feature = "clipboard"))]
        {
              eprintln!("Clipboard feature is not enabled. Please compile with '--features clipboard' or use the -o option to write to a file.");
         }

    } else {
        fs::write(&args.output, output_text)?;
        println!("Output completed: {}", args.output);
    }
    Ok(())
}
