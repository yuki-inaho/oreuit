＜ディレクトリ構造＞

.
├── src
│   └── main.rs
└── Cargo.toml

＜ファイル内容＞

--------------------------------------------------------------------------------
Cargo.toml:
--------------------------------------------------------------------------------
[package]
name = "oreuit"
version = "0.1.0"
edition = "2021"
authors = ["Name"]
rust-version = "1.70"

[dependencies]
clap = { version = "4.1", features = ["derive"] }
walkdir = "2.3"
encoding_rs = "0.8"
arboard = "3.4.1"


--------------------------------------------------------------------------------
src/main.rs:
--------------------------------------------------------------------------------
use clap::Parser;
use encoding_rs::SHIFT_JIS;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// ディレクトリ構造とファイル内容をまとめるツール
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "ディレクトリ構造とファイル内容をまとめるツール(uithub的なもの)"
)]
struct Args {
    /// 探索対象のディレクトリ（デフォルトはカレントディレクトリ）
    #[clap(short = 'd', long = "directory", default_value = ".")]
    directory: String,

    /// 許可する拡張子（カンマ区切り、例: .txt,.md,.py）。空文字の場合は既定のリストを使用
    #[clap(short = 'e', long = "extensions", default_value = "")]
    extensions: String,

    /// 無視する拡張子（カンマ区切り、例: .bin,.zip,...）。空文字の場合は無視しない
    #[clap(
        short = 'i',
        long = "ignore-extensions",
        default_value = ".bin,.zip,.tar,.gz,.7z,.rar,.exe,.dll,.so,.dylib,.a,.lib,.obj,.o,.class,.jar,.war,.ear,.ipynb,.jpg,.jpeg,.png,.gif"
    )]
    ignore_extensions: String,

    /// 出力ファイル名（デフォルトは summary.txt）
    #[clap(short = 'o', long = "output", default_value = "summary.txt")]
    output: String,

    /// 読み込み対象とするファイルの最大サイズ（バイト単位、デフォルトは 10485760 = 10MB）
    #[clap(long = "max-size", default_value = "10485760")]
    max_size: u64,

    /// 出力をファイルではなく、クリップボードにコピーする
    #[clap(short = 'c', long = "clipboard")]
    clipboard: bool,

    /// 無視するディレクトリ名（カンマ区切り、例: .git,node_modules,__pycache__ など）
    #[clap(
        long = "ignore-dirs",
        default_value = ".git,.vscode,target,node_modules,__pycache__,.idea,build,dist"
    )]
    ignore_dirs: String,
}

/// ファイル先頭の1024バイトにNULバイトが含まれていればバイナリファイルと判定する
fn is_binary(file_path: &Path) -> bool {
    if let Ok(mut file) = fs::File::open(file_path) {
        let mut buffer = [0u8; 1024];
        if let Ok(n) = file.read(&mut buffer) {
            return buffer[..n].iter().any(|&b| b == 0);
        }
    }
    true
}

/// UTF-8での読み込みを試み、失敗した場合はSHIFT_JISでデコードを試みる。
/// 両方失敗した場合は "[Cannot decode file content]" を返す。
fn read_file_contents(file_path: &Path) -> String {
    match fs::read_to_string(file_path) {
        Ok(text) => text,
        Err(_) => match fs::read(file_path) {
            Ok(bytes) => {
                let (cow, _, had_errors) = SHIFT_JIS.decode(&bytes);
                if had_errors {
                    "[Cannot decode file content]".to_string()
                } else {
                    cow.into_owned()
                }
            }
            Err(_) => "[Cannot decode file content]".to_string(),
        },
    }
}

/// 指定ディレクトリ以下を再帰的に探索し、
/// ・許可拡張子（allowed）に一致し、
/// ・かつ無視拡張子（ignore）に含まれないファイルをリストアップする。
/// また、無視するディレクトリ（ignore_dirs）内のファイルは探索しない。
fn collect_files(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
) -> Vec<PathBuf> {
    // WalkDir の filter_entry を用いて、無視するディレクトリは探索対象外にする
    let walker = WalkDir::new(directory).into_iter().filter_entry(|e| {
        if e.file_type().is_dir() {
            if let Some(name) = e.file_name().to_str() {
                return !ignore_dirs.contains(&name.to_string());
            }
        }
        true
    });

    let mut files = Vec::new();
    for entry in walker.filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let path = entry.path();
            if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                let ext_formatted = format!(".{}", ext.to_lowercase());
                // 拡張子フィルターのチェック
                if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                    continue;
                }
                if ignore.contains(&ext_formatted) {
                    continue;
                }
                files.push(path.to_path_buf());
            }
        }
    }
    // ファイルパスを相対パス順にソートする
    files.sort_by(|a, b| {
        a.strip_prefix(directory)
            .unwrap_or(a)
            .cmp(b.strip_prefix(directory).unwrap_or(b))
    });
    files
}

/// 指定ディレクトリのツリー形式の構造を生成する。
/// allowed, ignore のフィルターを適用し、ignore_dirs に含まれるディレクトリは除外する。
fn build_tree(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
) -> String {
    let base = directory
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or(".");
    let mut lines = vec![base.to_string()];
    build_tree_helper(directory, "", allowed, ignore, ignore_dirs, &mut lines);
    lines.join("\n")
}

/// 再帰的にディレクトリ構造を走査し、ツリー形式の文字列を生成する補助関数
fn build_tree_helper(
    path: &Path,
    prefix: &str,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    lines: &mut Vec<String>,
) {
    // ディレクトリ内のエントリを読み込み、名前でソートする
    let mut entries: Vec<fs::DirEntry> = match fs::read_dir(path) {
        Ok(iter) => iter.filter_map(|e| e.ok()).collect(),
        Err(_) => return,
    };
    entries.sort_by_key(|e| e.file_name());

    // ディレクトリとファイルを分ける
    let mut dirs = Vec::new();
    let mut files = Vec::new();
    for entry in entries {
        let entry_path = entry.path();
        let name = entry.file_name().into_string().unwrap_or_default();

        // 無視するディレクトリの場合はスキップ
        if entry_path.is_dir() {
            if ignore_dirs.contains(&name) {
                continue;
            }
            dirs.push(entry);
        } else if entry_path.is_file() {
            // ファイルの場合、拡張子フィルターを適用
            if let Some(ext_os) = entry_path.extension() {
                if let Some(ext) = ext_os.to_str() {
                    let ext_formatted = format!(".{}", ext.to_lowercase());
                    if !allowed.is_empty() && !allowed.contains(&ext_formatted) {
                        continue;
                    }
                    if ignore.contains(&ext_formatted) {
                        continue;
                    }
                }
            }
            files.push(entry);
        }
    }

    // ディレクトリを先に表示し、その後にファイルを表示する
    let mut all_entries = Vec::new();
    for d in dirs {
        all_entries.push((d, true));
    }
    for f in files {
        all_entries.push((f, false));
    }

    let count = all_entries.len();
    for (i, (entry, is_dir)) in all_entries.into_iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let name = entry.file_name().into_string().unwrap_or_default();
        lines.push(format!("{}{}{}", prefix, connector, name));

        // ディレクトリの場合は再帰処理
        if is_dir {
            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };
            build_tree_helper(
                &entry.path(),
                &new_prefix,
                allowed,
                ignore,
                ignore_dirs,
                lines,
            );
        }
    }
}

/// ツリー形式のディレクトリ構造と、各ファイルの相対パスおよび内容（またはスキップメッセージ）を連結したテキストを生成する
fn generate_output_text(
    directory: &Path,
    allowed: &HashSet<String>,
    ignore: &HashSet<String>,
    ignore_dirs: &HashSet<String>,
    max_size: u64,
) -> String {
    // ツリー形式のディレクトリ構造を生成
    let tree_text = build_tree(directory, allowed, ignore, ignore_dirs);
    // 対象ファイルの内容を取得
    let files = collect_files(directory, allowed, ignore, ignore_dirs);
    let mut file_contents = String::new();
    for file in files {
        let relative_path = file
            .strip_prefix(directory)
            .unwrap_or(&file)
            .to_string_lossy();
        let header = format!(
            "--------------------------------------------------------------------------------\n{}:\n--------------------------------------------------------------------------------\n",
            relative_path
        );
        let size = fs::metadata(&file).map(|m| m.len()).unwrap_or(0);
        let content = if size > max_size {
            "[File size exceeds limit; skipped]\n".to_string()
        } else if is_binary(&file) {
            "[Binary file skipped]\n".to_string()
        } else {
            read_file_contents(&file)
        };
        file_contents.push_str(&header);
        file_contents.push_str(&content);
        file_contents.push_str("\n\n");
    }
    format!(
        "＜ディレクトリ構造＞\n\n{}\n\n＜ファイル内容＞\n\n{}",
        tree_text, file_contents
    )
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();
    let dir = Path::new(&args.directory);

    // 既定の許可拡張子リスト（extensions 未指定の場合に使用）
    let default_allowed: HashSet<String> = [
        ".txt", ".md", ".py", ".js", ".java", ".cpp", ".c", ".cs", ".rb", ".go", ".rs"
    ]
    .iter()
    .map(|s| s.to_string())
    .collect();

    // 許可する拡張子の設定（入力値が空なら既定リストを採用）
    let allowed: HashSet<String> = if args.extensions.trim().is_empty() {
        default_allowed
    } else {
        args.extensions
            .split(',')
            .filter_map(|s| {
                let s = s.trim().to_lowercase();
                if s.is_empty() {
                    None
                } else if s.starts_with('.') {
                    Some(s)
                } else {
                    Some(format!(".{}", s))
                }
            })
            .collect()
    };

    // 無視する拡張子の設定
    let ignore: HashSet<String> = args
        .ignore_extensions
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_lowercase();
            if s.is_empty() {
                None
            } else if s.starts_with('.') {
                Some(s)
            } else {
                Some(format!(".{}", s))
            }
        })
        .collect();

    // 無視するディレクトリ名の設定
    let ignore_dirs: HashSet<String> = args
        .ignore_dirs
        .split(',')
        .filter_map(|s| {
            let s = s.trim().to_string();
            if s.is_empty() {
                None
            } else {
                Some(s)
            }
        })
        .collect();

    // 出力テキストの生成
    let output_text = generate_output_text(dir, &allowed, &ignore, &ignore_dirs, args.max_size);

    // クリップボードに出力する場合は arboard クレートを利用
    if args.clipboard {
        match arboard::Clipboard::new() {
            Ok(mut clipboard) => {
                clipboard.set_text(output_text)?;
                println!("出力内容をクリップボードにコピーしました。");
            }
            Err(e) => {
                eprintln!("クリップボード操作に失敗しました: {}", e);
            }
        }
    } else {
        fs::write(&args.output, output_text)?;
        println!("出力完了: {}", args.output);
    }
    Ok(())
}


